C
C PACKAGE NAME      FCONV
C
C***********************************************************************
C
C LATEST REVISION   MARCH 1992
C
C PURPOSE           CONVERTS 7600 RECORDS TO CRAY-1 RECORDS ACCORDING
C                   TO SINGLE SPECIFIED MODE.
C
C USAGE             CALL SCONV(SARRAY,CARRAY,CDIM,MODE,NBITS,LOCEND,IER)
C
C ARGUMENTS
C ON INPUT          SARRAY - INPUT ARRAY OF CDC7600 RECORD
C
C                   CDIM   - DIMENSION OF CRAY ARRAY
C
C                   MODE   - TYPE OR MODE OF CONVERSION
C                    0: CONVERT DPC CHARACTERS TO ASCII.
C                    1: BINARY BIT SERIAL - TRANSFER ALL DATA WITH
C                       NO CONVERSION.
C                    2: CONVERT BCD CHARACTERS TO ASCII.
C                    3: ASCII - PUT 8 CHARACTERS IN EACH CRAY WORD.
C                    4: EBCIDIC TO ASCII - NOT IMPLEMENTED.
C                    5: 7600 INTEGER TO CRAY INTEGER.
C                    6: 7600 FLOATING POINT OR INTEGER TO CRAY.
C                    7: DPC CARD IMAGE - CONVERT TO ASCII CHARACTERS.
C                    8: TRANSPARENT - DO BINARY BIT SERIAL CONVERSION.
C                    9: TRANSPARENT - INSERT EACH 7600 WORD (60 BITS)
C                       INTO CRAY WORD (64 BITS) RIGHT JUSTIFIED.
C
C                   NBITS  - NUMBER OF BITS TO CONVERT
C
C ARGUMENTS
C ON OUTPUT         CARRAY - RESULTANT CRAY ARRAY AFTER CONVERSIONS
C
C                   LOCEND - ADDRESS OF LAST WORD IN CONVERSION
C
C                   IER    - ERROR CODE (0 IS NO ERROR)
C                     1   LENGTH OF TABLE IS ZERO OR NEGATIVE
C                     2   ILLEGAL MODE
C                     3   MODE NOT IMPLEMENTED
C                     4   DIMENSION OF CRAY ARRAY EXCEEDED
C                     6   NUMBER OF BITS (NBITS) NOT DIVISIBLE BY 6
C                     8   NUMBER OF BITS (NBITS) NOT DIVISIBLE BY 8
C                     60  NUMBER OF BITS (NBITS) NOT DIVISIBLE BY 60
C
C I/O               NONE
C
C PRECISION         SINGLE
C
C REQUIRED LIBRARY  CCONV
C FILES             
C
C LANGUAGE          FORTRAN
C
C HISTORY           WRITTEN JANUARY 1983 BY MEMBERS OF THE SCIENTIFIC
C                   COMPUTING DIVISION OF NCAR IN BOULDER, COLO.
C
C PORTABILITY       NO PORTABILITY EFFORT HAS BEEN MADE.
C
C***********************************************************************
C
C     SUBROUTINE MCONV( SARRAY, CARRAY, CDIM, TABLE, LENTAB, IER )
C
C PURPOSE           CONVERTS 7600 MIXED MODE RECORDS TO CRAY-1
C                   RECORDS ACCORDING TO SPECIFIED TABLE OF MODES.
C
C USAGE             CALL MCONV (SARRAY,CARRAY,CDIM,TABLE,LENTAB,IER )
C
C ARGUMENTS
C ON INPUT          SARRAY - INPUT ARRAY OF CDC7600 RECORD
C                   CDIM   - DIMENSION OF CRAY ARRAY
C                   TABLE  - A TABLE OF CONVERSIONS
C                            TABLE(1,N) - MODE OF CONVERSION
C                            TABLE(2,N) - NUMBER OF BITS TO CONVERT
C                   LENTAB - LENGTH OF CONVERSION TABLE
C                   IER    - ERROR CODE (0 IS NO ERROR)
C                      1   LENGTH OF TABLE IS ZERO OR NEGATIVE
C                      2   ILLEGAL MODE
C                      3   MODE NOT IMPLEMENTED
C                      4   DIMENSION OF CRAY ARRAY EXCEEDED
C                      6   NUMBER OF BITS (NBITS) NOT DIVISIBLE BY 6
C                      8   NUMBER OF BITS (NBITS) NOT DIVISIBLE BY 8
C                      60  NUMBER OF BITS (NBITS) NOT DIVISIBLE BY 60
C
C ARGUMENTS
C ON OUTPUT         CARRAY - RESULTANT CRAY ARRAY AFTER CONVERSIONS
C                   TABLE  - A TABLE OF CONVERSIONS
C                      TABLE(3,1) - ADDRESS OF LAST WORD IN CONVERSION
C
C I/O               NONE
C
C PRECISION         SINGLE
C
C REQUIRED LIBRARY  CCONV
C FILES
C
C LANGUAGE          FORTRAN
C
C HISTORY           WRITTEN JANUARY 1983 BY MEMBERS OF THE SCIENTIFIC
C                   COMPUTING DIVISION OF NCAR IN BOULDER, COLO.
C
C PORTABILITY       NO PORTABILITY EFFORT HAS BEEN MADE.
C***********************************************************************
      SUBROUTINE SCONV(SARRAY,CARRAY,CDIM,MODE,NBITS,LOCEND,IER)
      IMPLICIT INTEGER (A-Z)
      DIMENSION SARRAY(1), CARRAY(1), TABLE(3,1)
C
      TABLE(1,1) = MODE
      TABLE(2,1) = NBITS
      CALL MCONV( SARRAY, CARRAY, CDIM, TABLE, 1, IER )
      LOCEND = TABLE(3,1)
C
      RETURN
      END
      SUBROUTINE MCONV( SARRAY, CARRAY, CDIM, TABLE, LENTAB, IER )
C
      IMPLICIT INTEGER (A-Z)
      DIMENSION SARRAY(1), CARRAY(1), TABLE(3,1)
C
C
C
      DATA SIX, EIGHT, SIXTY / 6, 8, 60 /
      DATA ERUNIT / 6 /
C
C               NCAR STATISTICS CALL.
C
C
C
C
C
C
C               CHECK LENGTH OF TABLE IS GREATER THAN ZERO.
C
      IER = 0
      IF( LENTAB .LE. 0 ) THEN
      WRITE( ERUNIT, 2000 ) LENTAB
      IER = 1
      GO TO 400
      END IF
C
C               INITIALIZE LOCATION IN 7600 ARRAY (NSKIP) AND CRAY
C               ARRAY (LOCCR).
C
      NSKIP = 0
      LOCCR = 1
C
C               LOOP OVER EACH REQUESTED CONVERSION.
C
      DO 300 ITAB = 1, LENTAB
      MODE  = TABLE(1,ITAB)
      NBITS = TABLE(2,ITAB)
      IF( MODE .LT. 0 .OR. MODE .GT. 12 ) THEN
      WRITE( ERUNIT, 2001 ) ITAB, MODE, NBITS
      IER = 2
      GO TO 200
      END IF
C
      GO TO (10,20,30,40,50,60,70,80,90,100,110,120,130) MODE+1
C
C               MODE 0: CONVERT DPC CHARACTERS TO ASCII.
C
   10 CONTINUE
      IF( MOD( NBITS, 6 ) .NE. 0 ) THEN
      WRITE( ERUNIT, 2002 ) ITAB, MODE, NBITS, SIX
      IER = 6
      END IF
      NCHAR = NBITS/6
      NCRWD = (NCHAR+7)/8
      IF( LOCCR+NCRWD-1 .GT. CDIM ) THEN
      WRITE( ERUNIT, 2004 ) ITAB, MODE, CDIM
      IER = 4
      GO TO 400
      END IF
      CALL GBYTES( SARRAY, CARRAY(LOCCR), NSKIP, 48, 0, NCRWD )
      LOCEND = LOCCR + NCRWD - 1
      DO 11 LOOP = LOCCR, LOCEND
      CARRAY(LOOP) = SHIFTL(CARRAY(LOOP),16)
      CALL DPCASC( CARRAY(LOOP), 8, CARRAY(LOOP) )
   11 CONTINUE
C               BLANK FILL THE LAST CHARACTERS OF LAST CRAY WORD.
      LSTWD = MOD(NCHAR,8)
      IF( LSTWD .NE. 0 ) THEN
      MSKOUT = MASK(LSTWD*8)
      EMPTY = 8 - LSTWD
      MASKIN = 0
      DO 12 LOOP = 1, EMPTY
      MASKIN = SHIFTL(MASKIN,8) .OR. 040B
   12 CONTINUE
      CARRAY(LOCEND) = CARRAY(LOCEND) .AND. MSKOUT .OR. MASKIN
      END IF
C
      GO TO 200
C
C               MODE 1: BINARY BIT SERIAL - TRANSFER ALL DATA WITH
C                       NO CONVERSION.
C
   20 CONTINUE
      NCRWD = (NBITS+63)/64
      IF( LOCCR+NCRWD-1 .GT. CDIM ) THEN
      WRITE( ERUNIT, 2004 ) ITAB, MODE, CDIM
      IER = 4
      GO TO 400
      END IF
      CALL GBYTES( SARRAY, CARRAY(LOCCR), NSKIP, 64, 9, NCRWD )
      LSTWD = MOD(NBITS,64)
      IF( LSTWD .NE. 0 ) THEN
      LOCEND = LOCCR + NCRWD - 1
      CARRAY(LOCEND) = CARRAY(LOCEND) .AND. MASK(LSTWD)
      END IF
      GO TO 200
C
C               MODE 2: CONVERT BCD CHARACTERS TO ASCII.
C
   30 CONTINUE
      GO TO 50
C     IF( MOD( NBITS, 6 ) .NE. 0 ) THEN
C     WRITE( ERUNIT, 2002 ) ITAB, MODE, NBITS, SIX
C     IER = 6
C     END IF
C     NCHAR = NBITS/6
C     NCRWD = (NCHAR+7)/8
C     IF( LOCCR+NCRWD-1 .GT. CDIM ) THEN
C     WRITE( ERUNIT, 2004 ) ITAB, MODE, CDIM
C     IER = 4
C     GO TO 400
C     END IF
C     CALL GBYTES( SARRAY, CARRAY(LOCCR), NSKIP, 48, 0, NCRWD )
C     LOCEND = LOCCR + NCRWD - 1
C     DO 31 LOOP = LOCCR, LOCEND
C     CARRAY(LOOP) = SHIFTL(CARRAY(LOOP),16)
C     CALL BCDASC( CARRAY(LOOP), 8, CARRAY(LOOP) )
C  31 CONTINUE
C               BLANK FILL THE LAST CHARACTERS OF LAST CRAY WORD.
C     LSTWD = MOD(NCHAR,8)
C     IF( LSTWD .NE. 0 ) THEN
C     MSKOUT = MASK(LSTWD*8)
C     EMPTY = 8 - LSTWD
C     MASKIN = 0
C     DO 32 LOOP = 1, EMPTY
C     MASKIN = SHIFTL(MASKIN,8) .OR. 040B
C  32 CONTINUE
C     CARRAY(LOCEND) = CARRAY(LOCEND) .AND. MSKOUT .OR. MASKIN
C     END IF
C
C     GO TO 200
C
C               MODE 3: ASCII - PUT 8 CHARACTERS IN EACH CARY WORD.
C
   40 CONTINUE
      IF( MOD( NBITS, 8 ) .NE. 0 ) THEN
      WRITE(ERUNIT,2002) ITAB, MODE, NBITS, EIGHT
      IER = 8
      END IF
      NCHAR = NBITS/8
      NCRWD = (NCHAR+7)/8
      IF( LOCCR+NCRWD-1 .GT. CDIM ) THEN
      WRITE( ERUNIT, 2004 ) ITAB, MODE, CDIM
      IER = 4
      GO TO 400
      END IF
      CALL GBYTES(SARRAY, CARRAY(LOCCR), NSKIP, 64, 0, NCRWD )
C               BLANK FILL THE LAST CHARACTERS OF LAST CRAY WORD.
      LSTWD = MOD(NCHAR,8)
      IF( LSTWD .NE. 0 ) THEN
      LOCEND = LOCCR + NCRWD - 1
      MSKOUT = MASK(LSTWD*8)
      EMPTY = 8 - LSTWD
      MASKIN = 0
      DO 42 LOOP = 1, EMPTY
      MASKIN = SHIFTL(MASKIN,8) .OR. 040B
   42 CONTINUE
      CARRAY(LOCEND) = CARRAY(LOCEND) .AND. MSKOUT .OR. MASKIN
      END IF
C
      GO TO 200
C
C               MODE 4: EBCIDIC TO ASCII - NOT IMPLEMENTED.
C
   50 CONTINUE
      WRITE( ERUNIT, 2003 ) ITAB, MODE, NBITS
      IER = 3
      NCRWD = 0
      GO TO 200
C
C               MODE 5: 7600 INTEGER TO CRAY INTEGER.
C
   60 CONTINUE
      IF( MOD( NBITS, 60 ) .NE. 0 ) THEN
      WRITE( ERUNIT, 2002 ) ITAB, MODE, NBITS, SIXTY
      IER = 60
      END IF
      NCRWD = NBITS/60
      IF( LOCCR+NCRWD-1 .GT. CDIM ) THEN
      WRITE( ERUNIT, 2004 ) ITAB, MODE, CDIM
      IER = 4
      GO TO 400
      END IF
      CALL GBYTES( SARRAY, CARRAY(LOCCR), NSKIP, 60, 0, NCRWD )
      CALL I7TIC( CARRAY(LOCCR), NCRWD )
      GO TO 200
C
C               MODE 6: 7600 FLOATING POINT OR INTEGER TO CRAY.
C
   70 CONTINUE
      IF( MOD( NBITS, 60 ) .NE. 0 ) THEN
      WRITE( ERUNIT, 2002 ) ITAB, MODE, NBITS, SIXTY
      IER = 60
      END IF
      NCRWD = NBITS/60
      IF( LOCCR+NCRWD-1 .GT. CDIM ) THEN
      WRITE( ERUNIT, 2004 ) ITAB, MODE, CDIM
      IER = 4
      GO TO 400
      END IF
      CALL GBYTES( SARRAY, CARRAY(LOCCR), NSKIP, 60, 0, NCRWD )
      CALL NC7TC( CARRAY(LOCCR), NCRWD )
      GO TO 200
C
C               MODE 7: DPC CARD IMAGE - CONVERT TO ASCII CHARACTERS.
C
   80 CONTINUE
      GO TO 10
C
C               MODE 8: TRANSPARENT - DO BINARY BIT SERIAL CONVERSION.
C
   90 CONTINUE
      GO TO 20
C
C               MODE 9: TRANSPARENT - INSERT EACH 7600 WORD (60 BITS)
C                       INTO CRAY WORD (64 BITS) RIGHT JUSTIFIED.
C
  100 CONTINUE
      IF( MOD( NBITS, 60 ) .NE. 0 ) THEN
      WRITE( ERUNIT, 2002 ) ITAB, MODE, NBITS, SIXTY
      IER = 60
      END IF
      NCRWD = NBITS/60
      IF( LOCCR+NCRWD-1 .GT. CDIM ) THEN
      WRITE( ERUNIT, 2004 ) ITAB, MODE, CDIM
      IER = 4
      GO TO 400
      END IF
      CALL GBYTES( SARRAY, CARRAY(LOCCR), NSKIP, 60, 0, NCRWD )
      GO TO 200
C
C               MODE 10: CONVERT 8 LEFTMOST DPC CHARACTERS OF 7600
C                        WORD TO ASCII (A10 TO A8 CONVERSION)
C
  110 CONTINUE
      IF( MOD( NBITS, 60 ) .NE. 0 ) THEN
      WRITE( ERUNIT, 2002 ) ITAB, MODE, NBITS, SIXTY
      IER = 60
      END IF
      NCHAR = NBITS/6
      NCRWD = (NCHAR+9)/10
      IF( LOCCR+NCRWD-1 .GT. CDIM ) THEN
      WRITE( ERUNIT, 2004 ) ITAB, MODE, CDIM
      IER = 4
      GO TO 400
      END IF
      CALL GBYTES( SARRAY, CARRAY(LOCCR), NSKIP, 48, 12, NCRWD )
      LOCEND = LOCCR + NCRWD - 1
      DO 111 LOOP = LOCCR, LOCEND
      CARRAY(LOOP) = SHIFTL(CARRAY(LOOP),16)
      CALL DPCASC( CARRAY(LOOP), 8, CARRAY(LOOP) )
  111 CONTINUE
C
      GO TO 200
C
C               MODE 11: CONVERT 8 RIGHTMOST DPC CHARACTERS OF 7600
C                        WORD TO ASCII (R10 TO R8 CONVERSION)
C
  120 CONTINUE
      IF( MOD( NBITS, 60 ) .NE. 0 ) THEN
      WRITE( ERUNIT, 2002 ) ITAB, MODE, NBITS, SIXTY
      IER = 60
      END IF
      NCHAR = NBITS/6
      NCRWD = (NCHAR+9)/10
      IF( LOCCR+NCRWD-1 .GT. CDIM ) THEN
      WRITE( ERUNIT, 2004 ) ITAB, MODE, CDIM
      IER = 4
      GO TO 400
      END IF
      CALL GBYTES( SARRAY, CARRAY(LOCCR), NSKIP+12, 48, 12, NCRWD )
      LOCEND = LOCCR + NCRWD - 1
      DO 121 LOOP = LOCCR, LOCEND
      CARRAY(LOOP) = SHIFTL(CARRAY(LOOP),16)
      CALL DPCASC( CARRAY(LOOP), 8, CARRAY(LOOP) )
  121 CONTINUE
C
      GO TO 200
C
C               MODE 12: SKIP PRESCRIBED NUMBER OF BITS IN 7600 ARRAY.
C
  130 CONTINUE
      NCRWD = 0
      GO TO 200
C
C               END OF CONVERSION LOOP - UPDATE POINTERS.
C
  200 CONTINUE
      NSKIP = NSKIP + NBITS
      LOCCR = LOCCR + NCRWD
      TABLE(3,ITAB) = LOCCR - 1
  300 CONTINUE
  400 CONTINUE
      RETURN
 2000 FORMAT(' LENGTH OF TABLE (',I4,') NOT GREATER THAN ZERO - EXIT.')
 2001 FORMAT(' CONVERSION NUMBER ',I3,': MODE (',I3,') ILLEGAL - SKIP',
     A I6,' BITS IN INPUT ARRAY')
 2002 FORMAT(' CONVERSION NUMBER ',I3,', MODE ',I2,':NUMBER OF BITS (',
     A I6,') NOT MULTIPLE OF ',I2,'- TRUNCATE.')
 2003 FORMAT(' CONVERSION NUMBER ',I3,': MODE (',I1,') NOT IMPLEMENTED'
     A ' - SKIP',I6,' BITS IN INPUT ARRAY.')
 2004 FORMAT(' CONVERSION NUMBER ',I3,': MODE (',I1,') WILL OVERFLOW '
     A 'CRAY ARRAY OF LENGTH ',I6', RETURN.')
      END
      SUBROUTINE I7TIC (A,N)
C
      INTEGER A(N)
      INTEGER T
C
C ARRAY A IS ASSUMED TO BE OF LENGTH N.  EACH WORD
C OF A CONTAINS A 60-BIT 7600-FORMAT INTEGER,  RIGHT-JUSTIFIED.
C THE ROUTINE I7TIC RETURNS, IN THE ARRAY A, THE EQUIVALENT INTEGERS
C IN CRAY FORMAT.
C
      INTEGER S,M
C
      DO 99 I = 1,N
C
C TEST THE SIGN BIT, IF ON COMPLEMENT THE INTEGER
C
      T = A(I)
      S = AND(SHIFTR(T,59),1)
      IF (S.NE.0) A(I) = OR(T,MASK(4))+1
   99 CONTINUE
      RETURN
      END
      SUBROUTINE NC7TC (A,N)
C
      INTEGER A(N)
      INTEGER T
C
C THE ARRAY A IS ASSUMED TO BE OF LENGTH N.  EACH WORD
C OF A CONTAINS A 60-BIT 7600-FORMAT INTEGER OR REAL, RIGHT-JUSTIFIED.
C THE ROUTINE RETURNS, IN THE ARRAY A, THE EQUIVALENT INTEGERS
C OR REALS IN CRAY FORMAT.  AN A(I) WHICH IS INDEFINITE, INFINITE, OR
C UNNORMALIZED YIELDS A VALUE WHICH IS INFINITE - THE SIGN BIT IS SET
C APPROPRIATELY AND THE LOWER THREE BITS OF A(I) INDICATE WHICH ONE
C OR MORE OF THE ABOVE CONDITIONS CAUSED THE INFINITE TO BE GENERATED.
C
      INTEGER S,E,M
C
         DO 103 I=1,N
C
C PICK OFF THE SIGN, EXPONENT, AND MANTISSA.
C
         T = A(I)
         S=AND(SHIFTR(T,59),1B)
         E=AND(SHIFTR(XOR(T,-S),48),3777B)
         M=AND(XOR(T,-S),7777777777777777B)
C
C IF THE EXPONENT OF A(I) IS PRECISELY ZERO, GENERATE A CRAY INTEGER.
C
         IF (E.NE.0) GO TO 101
         A(I)=(1-2*S)*M
         GO TO 103
C
C A(I) IS REAL - CHECK FOR INDEFINITE, INFINITE, UN-NORMALIZED.
C
  101    IF (E.NE.1777B .AND. E.NE.3777B .AND. M.GE.4000000000000000B)
     1                                                         GO TO 102
         A(I)=OR(SHIFTL(S,63),600004000000000000000B)
C
C SET LOWER BITS TO INDICATE PROBLEM WHICH CAUSED ILLEGAL REAL.
C
         IF (E.EQ.1777B) A(I)=OR(A(I),4B)
         IF (E.EQ.3777B) A(I)=OR(A(I),2B)
         IF (M.LT.4000000000000000B) A(I)=OR(A(I),1B)
         GO TO 103
C
C A(I) IS REAL AND NOTHING IS WRONG WITH IT.
C
  102    IF (E.LT.2000B) E=E+1
         A(I)=OR(OR(SHIFTL(S,63),SHIFTL(36060B+E,48)),M)
C
C END OF LOOP.
C
  103    CONTINUE
C
C THE ENTIRE ARRAY IS DONE - RETURN TO THE CALLER.
C
      RETURN
C
C REVISION HISTORY
C
C MAR 1992 FIX DOCUMENTATION TO INCLUDE MODE VALUES
C
      END
