         SOFTWARE FOR READING RAF (GENPRO) TAPES

 =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    Revision by RLR <930726.1030>: corrected some misleading instructions.
    Revision by RLR <920717.0900>: corrected some misleading instructions,
     revised some of the text, added two new PARAMETERs (IBYTSZ and NVARMX)
     and recommended using a 64-bit compiler option for the Cray version.
     old (new) line numbers for code changes:
       in all Subroutines GENHDR lines 53-55 (53-56)
       in all Subroutines GENDAT lines 30-31 (30-32)
       in all Subroutines UNPCK  lines  9-10 ( 9-11)
       in 64-bit Subroutine GENDAT - added 3 lines after 44
    Revision by RLR <920624.1300>: old (new) line numbers:
       in 16-bit Subroutine UNPCK line  14 & added line after  17 (18)
       in 32-bit Subroutine UNPCK line  14 & added line after  17 (18)
       in DEC 32-bit Subroutine UNPCK line  14 & added line after  29 (30)
       in 64-bit Subroutine UNPCK line 41 & added line after 62 (63)
       in HP/1000 Subroutine UNPCK line 14 & added line after 17 (18)
       in VAX Subroutine UNPCK line 12 & added line after 24 (25)
       in Cray Subroutine UNPCK line 22 & added line after 33 (34)
    Revision by RLR <900703.1700>: in VAX Subroutine UNPCK ~ line 20.
 =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


    THESE FORTRAN SOFTWARE PROGRAMS PROVIDE THE RECIPIENT OF RAF PROCESSED
DATA TAPES WITH A MEANS FOR READING THE INFORMATIONAL HEADER FILES AND DATA
FILES WITH VARIOUS COMPUTERS.

    THE RAF PROVIDES THE PROCESSED AIRCRAFT DATA TO USERS AS PURE BINARY
DATA ON ONE-HALF INCH MAGNETIC TAPES AND EXABYTE CARTRIDGES.  THE ONE-HALF
INCH TAPE DATA ARE WRITTEN IN 1600 BPI PHASE-ENCODED OR 6250 BPI GCR FORMATS
AT THE USER'S REQUEST.  THE EXABYTE CARTRIDGES CAN BE WRITTEN IN LOW- OR HIGH-
DENSITY FORMATS.  (SINCE THESE DATA ARE PROCESSED AT NCAR, THEY ARE ALSO
AVAILABLE AS COS-BLOCKED, TAPE-IMAGE VOLUMES ON THE NCAR MASS STORAGE SYSTEM.)
THE TAPES CONSIST OF AN INFORMATIONAL HEADER FILE FOLLOWED BY A DATA FILE (OR
FILES), GENERALLY AN ENTIRE FLIGHT.  THE HEADER FILE IS FORMATTED IN ASCII
CHARACTERS CONTAINING INFORMATION SUCH AS THE FLIGHT DATE, THE VARIABLES
RECORDED IN THE DATA FILE, AND THEIR LOCATIONS IN A LOGICAL RECORD.

    THE DATA FILES ARE PHYSICAL RECORDS THAT CONTAIN ONE OR MORE LOGICAL
RECORDS OF DATA--A LOGICAL RECORD TYPICALLY BEING ONE SECOND OF DATA.
INFORMATION ON THE SIZES OF BOTH THE LOGICAL AND PHYSICAL RECORDS ARE GIVEN
IN THE HEADER.  THE DATA VALUES ARE WRITTEN IN PURE BINARY, 32 BITS PER WORD.
(THE NUMBER OF BITS PER WORD MAY NOT ALWAYS BE 32, BUT THIS IS THE STANDARD
FORMAT.  THE NUMBER OF BITS CAN BE FOUND IN THE HEADER UNDER THE COLUMN TITLED
'BITS.')  TO WRITE THE VALUES AS PURE BINARY ON MAGNETIC TAPE, THEY WERE FIRST
CONVERTED TO POSITIVE INTEGERS BY ADDING A BIAS AND THEN MULTIPLYING BY A
SCALE FACTOR.  TO CONVERT THESE VALUES ON THE TAPE BACK TO FLOATING-POINT
NUMBERS, THE PROCESS MUST BE REVERSED, THAT IS, DIVIDE BY A SCALE FACTOR AND
SUBTRACT A BIAS.  THIS INFORMATION CAN BE OBTAINED FROM THE DATA'S HEADER
FILE.

    THESE SUBROUTINES HAVE BEEN WRITTEN TO BE AS PORTABLE AS POSSIBLE USING
FORTRAN-77.  IF THE USER ELECTS TO WRITE HIS/HER OWN SOFTWARE, WE HOPE THAT
THESE LISTINGS WILL PROVIDE SOME INSIGHT AS TO HOW TO APPROACH THE TASK.
THE SUBROUTINES WILL READ THE HEADER OF AN RAF TAPE AND USE THIS INFORMATION
TO READ THE DATA FILES INTO ARRAYS IN THE COMPUTER.  THE THREE SUBROUTINES
INCLUDED ARE CALLED GENHDR, GENDAT, AND UNPCK.  GENHDR AND GENDAT ARE TO BE
CALLED FROM A USER-WRITTEN DRIVER OR MAIN PROGRAM.  GENHDR AND GENDAT CAN BE
USED ON ANY COMPUTER BY ENTERING THE COMPUTER'S WORD SIZE (IWDSZ).  THE USER
MUST SELECT THE VERSION OF UNPCK WRITTEN SPECIFICALLY FOR THE COMPUTER WITH
ITS CORRESPONDING WORD SIZE (16, 32, OR 64 BITS).

    WHILE THESE SUBROUTINES ARE PORTABLE, ONE MUST SPECIFY THE BASIC WORD
SIZE OF THE COMPUTER BEING USED.  VERSIONS HAVE BEEN CONFIGURED AND TESTED
ON SOME OF THE COMPUTERS AT NCAR:  HP1000 (16-BIT)*, DEC VAX 11/780 (32-BIT),
AND CRAY (64-BIT).

    TO USE THESE SUBROUTINES, ONE MUST FIRST SET THE PARAMETER IDWSZ IN
GENDAT TO THE NUMBER OF BITS AN INTEGER VARIABLE USES ON YOUR COMPUTER.
THEN THE USER MUST SELECT THE VERSION OF UNPCK THAT CORRESPONDS TO THE
MACHINE'S WORD SIZE.  IT IS ADVISED THAT THE USER FIRST TRY THE UNPCK
ROUTINE SUPPLIED FOR HIS/HER COMPUTER BEFORE ATTEMPTING TO WRITE A VERSION
FROM SCRATCH.

    IF YOU HAVE ANY QUESTIONS OR SUGGESTIONS, PLEASE DIRECT THEM TO RON RUTH,
NCAR, (303)497-1084 (email address = ruth@ncar.ucar.edu).  ALSO, IF YOU
DEVELOP ANY SOFTWARE FOR UNPCK ON DIFFERENT COMPUTERS, WE WOULD WELCOME
YOUR CONTRIBUTIONS.

------
* WHEN TESTING THE HP/1000 SERIES F VERSION RUNNING RTE-6/VM, A SYSTEM BUG
   WAS FOUND.  IT WAS REPORTED TO HP IN APRIL 1985 AND SHOULD, HOPEFULLY,
   HAVE BEEN CORRECTED BY NOW.





     THESE FORTRAN-77 SUBROUTINES WILL READ THE "NEW" GENPRO II DATA TAPES
(ONES GENERATED AFTER DECEMBER 1983).  THE THREE SUBROUTINES INCLUDED ARE
CALLED 'GENHDR,' 'GENDAT,' AND 'UNPCK.'  THE DESCRIPTIONS OF THESE ROUTINES
FOLLOW ON THE NEXT PAGE.  THERE ARE FOUR VERSIONS OF 'UNPCK' SUPPLIED:  ONE
FOR A 16-BIT MACHINE, A 32-BIT MACHINE, A 32-BIT DEC MACHINE (A SEPARATE
VERSION IS NECESSARY BECAUSE OF DEC'S UNIQUE BYTE ORDERING), AND A 64-BIT
MACHINE.  USE ONLY THE VERSION THAT CONFORMS TO YOUR MACHINE'S WORD SIZE.
ALSO INCLUDED ARE EXAMPLE PROGRAMS FOR AN HP1000, DEC VAX 11/780 AND A CRAY.


IMPORTANT NOTES:

 1)  THROUGHOUT THIS DOCUMENT A BYTE MEANS 8 BITS.
 2)  TO USE THESE ROUTINES, ONE MUST FIRST SET THE PARAMETER IWDSZ IN
      SUBROUTINE GENDAT TO THE NUMBER OF BITS AN INTEGER VARIABLE USES.
 3)  IF WORKING ON THE 64-BIT CRAY, IT IS IMPORANT TO SPECIFY THE CORRECT
      BYTE SIZE OF THE INPUT DATA ARRAY (INTEGER*8).  A PARAMETER (IBYTSZ)
      HAS BEEN CALCULATED TO DO THIS AUTOMATICALLY IN THE 64-BIT VERSION
      OF UNPCK.  ONE CAN DEFAULT ALL INTEGER DECLARATIONS TO 64 BITS BY
      SPECIFYING THE OPTION " -i 64 " WHEN INVOKING CRAY'S FORTRAN-77
      COMPILER.
 4)  THE NUMBER OF VARIABLES ON THE DATA TAPE CAN VARY WITH EACH DATA SET
      DELIVERED TO A USER.  TYPICALLY FEWER THAN 300 EXIST, BUT SOME LARGE
      PROJECTS HAVE CREATED MORE.  THE PARAMETER 'NVARMX' (WHICH IS INITIALLY
      SET TO BE 300) CAN BE SET TO THE EXACT NUMBER OF VARIABLES IN YOUR DATA
      SET IN CASE YOUR MACHINE HAS MEMORY LIMITATIONS OR THERE ARE MORE THAN
      300 VARIABLES.
 5)  YOU MAY HAVE TO DECLARE THE COMMON BLOCK 'GENBLK' IN A BLOCK DATA
      SUBPROGRAM FOR THESE ROUTINES TO WORK ON YOUR MACHINE.  USE THE
      FOLLOWING LINES AS A TEMPLATE, IF NEEDED.

      BLOCK DATA GNBLOK
      PARAMETER (NVARMX=300)
      COMMON / GENBLK / ILGBIT,IDATLG,IRATE(NVARMX),IPOS(NVARMX),
     &                  TERM(NVARMX),FACTR(NVARMX),NVAR,NLOGRC,IDSIZ
      END


****************************************************************************
* DESCRIPTION FOR SUBROUTINE GENHDR (4 VERSIONS SUPPLIED)                  *
****************************************************************************
     SUBROUTINE GENHDR SHOULD BE USED TO READ THE HEADER FILE OF THE
GENPRO II TAPE.  THE CALL IS:

     CALL GENHDR (LUIN,LUOUT)

     WHERE:
       LUIN  - IS THE LOGICAL UNIT NUMBER OF THE INPUT DEVICE FROM WHICH
                THE DATA ARE READ.
       LUOUT - IS THE LOGICAL UNIT NUMBER OF THE OUTPUT DEVICE TO WHICH THE
                HEADER SHOULD BE WRITTEN.

NOTE:  TO READ THE DATA FILE, IT IS FIRST NECESSARY TO CALL GENHDR AND READ
        THE HEADER FILE, BECAUSE PERTINENT INFORMATION MUST BE OBTAINED FROM
        THE HEADER FILE BEFORE READING THE DATA FILE.

****************************************************************************
* DESCRIPTION FOR SUBROUTINE GENDAT (4 VERSIONS SUPPLIED)                  *
****************************************************************************
     SUBROUTINE GENDAT SHOULD BE USED TO READ A LOGICAL DATA RECORD.  THE
DATA VALUES WILL BE PLACED IN 'DATARY' SO THAT A USER MAY MANIPULATE THEM IN
ANY WAY S/HE DESIRES.  EACH CALL TO GENDAT READS THE NEXT LOGICAL RECORD
IN A SEQUENTIAL MANNER, MEANING THAT TO REACH THE 50TH LOGICAL DATA RECORD,
GENDAT WOULD HAVE TO BE CALLED 50 TIMES.  THE CALL IS:

     CALL GENDAT (LUIN,LUOUT,DATARY,ISTAT)

     WHERE:
       LUIN   - IS THE LOGICAL UNIT NUMBER OF THE INPUT DEVICE FROM WHICH
                 THE DATA ARE READ.
       LUOUT  - IS THE LOGICAL UNIT NUMBER OF THE DEVICE TO WHICH ALL ERROR
                 MESSAGES ARE WRITTEN.
       DATARY - IS THE ARRAY TO CONTAIN ONE CONTINUOUS LOGICAL RECORD OF
                 DATA.  NOTE:  THIS ARRAY MUST BE LARGE ENOUGH TO CONTAIN
                 ONE UNPACKED LOGICAL DATA RECORD !!
       ISTAT  - IS A STATUS RETURN VARIABLE:
                 ISTAT <  0   READ ERROR
                 ISTAT =  0   SUCCESSFUL READ
                 ISTAT >  0   EOF SENSED

NOTE:  YOU MUST SET THE PARAMETER 'IWDSZ' TO YOUR MACHINE WORD SIZE BEFORE
        USING GENDAT !!!  YOU MAY ALSO HAVE TO ADJUST THE PARAMETER 'NVARMX.'

****************************************************************************
* DESCRIPTION FOR SUBROUTINE UNPCK (7 VERSIONS SUPPLIED)                   *
****************************************************************************
     SUBROUTINE UNPCK UNPACKS THE PACKED-INTEGER DATA READ DIRECTLY FROM THE
GENPRO II TAPE, PROVIDING UNPACKED REAL DATA.  IT IS ONLY USED AS A GENDAT
SUBROUTINE, SO THE USER NEED NOT BE CONCERNED WITH ITS DETAILS.  THE CALL IS:

     CALL UNPCK (DATARY,IDAT)

     WHERE:
       DATARY - IS THE ARRAY TO CONTAIN THE UNPACKED REAL DATA.
       IDAT   - IS THE INTEGER ARRAY THAT CONTAINS THE PACKED DATA.



           SPECIAL NOTE FOR 16-BIT MACHINE USERS

     IT MAY BE NECESSARY TO DECLARE ILGBIT AND IDSIZ IN THE / GENBLK /
COMMON BLOCK AND THE IFBIT VARIABLE LOCAL TO GENHDR AS 32-BIT LONG INTEGERS.
THIS IS USUALLY DONE IN THE FOLLOWING MANNER:

   FOR GENHDR:

     INTEGER*4 ILGBIT,IDSIZ,IFBIT

   FOR GENDAT:

     INTEGER*4 ILGBIT,IDSIZ,IRSIZ

   FOR UNPCK:

     INTEGER*4 IDAT(1),ILGBIT,IDSIZ

   FOR ALL OTHER ROUTINES THAT REFERENCE COMMON BLOCK / GENBLK / :

     INTEGER*4 ILGBIT,IDSIZ


            SPECIAL NOTES FOR USERS OF D.E.C. MACHINES (VMS 3.1)

    BECAUSE OF THE WAY DEC MACHINES HANDLE INTEGER VARIABLES, RAF HAS INCLUDED
A MODIFIED VERSION OF UNPCK THAT SHOULD ONLY BE USED WITH DIGITAL EQUIPMENT
CORPORATION MACHINES.  IT HANDLES THE BYTE SWAPPING THAT IS NECESSARY (DEC
MACHINES AND COMPATIBLES ARRANGE BYTES IN AN ORDER THAT IS DIFFERENT FROM
MANY OTHER COMPUTERS, I.E., A 40A1E7B5 HEX IS READ SERIALLY AS B5E7A140 HEX ON
A DEC MACHINE).  THE MOUNT COMMAND BELOW, WHEN MODIFIED FOR YOUR APPLICATION,
SHOULD BE USED ON A VAX MACHINE TO PROPERLY READ THE TAPE.  ALSO, SOME USERS
HAVE DEEMED IT NECESSARY TO USE THE 'CHECK=NOOVERFLOW' OPTION WHEN COMPILING
THE UNPCK SUBROUTINE -- THIS IS DONE WITH THE FOLLOWING COMMAND:
'FOR/CHECK=NOOVERFLOW (FILESPECIFIER)'.

             $ MOUNT/FOREIGN/NOWRITE/BLOCKSIZE=10440 MMB0:
 WHERE:

 $               - IS THE NORMAL PROMPTING CHARACTER FROM THE VAX
 FOREIGN         - SPECIFIES THE TAPE IS IN A NON-DEC FORMAT
 NOWRITE         - ASSURES THE TAPE WILL NOT BE WRITTEN OVER
 BLOCKSIZE=10440 - SPECIFIES THE LARGEST RECORD TO BE READ IN--THIS EXAMPLE IS
                    10,440 BYTES LONG (THE DATA RECORDS) WHICH OVERRIDES THE
                    THE DEFAULT OF 512 BYTES.
 MMB0:           - IS THE DEVICE NAME OF THE TAPE DRIVE THE TAPE IS ON.  THIS
                    WILL SURELY BE SITE-DEPENDENT.

THEN, IN YOUR DRIVER PROGRAM, OPEN THE LOGICAL UNIT WITH THIS OPEN STATEMENT
(EXAMPLE FOR LOGICAL UNIT 2 AND TAPE DEVICE NAME MMB0:):

OPEN (2,FILE='MMB0:',FORM='UNFORMATTED',RECORDTYPE='VARIABLE',STATUS='OLD')


      SUBROUTINE GENHDR (LUIN,LUOUT)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     SUBROUTINE GENHDR WILL READ A GENPRO II HEADER, WRITE IT OUT (TO C
C LOGICAL UNIT NUMBER LUOUT), STORE THE VALUES NECESSARY TO READ THE   C
C DATA FILE, AND WRITE OUT A TABLE OF THE VARIABLES, THEIR INDICES     C
C WITHIN THE DATA ARRAY (WHEN CREATED) AND THEIR RATES.                C
C                                                                      C
C ARGUMENTS USED BY GENHDR:                                           C
C   LUIN     - THE LOGICAL UNIT NUMBER OF THE INPUT DEVICE FROM WHICH  C
C               THE DATA ARE READ.                                     C
C   LUOUT    - THE LOGICAL UNIT NUMBER OF THE DEVICE TO WHICH THE      C
C               HEADER SHOULD BE WRITTEN.                              C
C                                                                      C
C VARIABLES IN GENHDR:                                                 C
C   ILGBIT   - THE NUMBER OF BITS PER LOGICAL DATA RECORD.             C
C   IDATLG   - THE NUMBER OF LOGICAL DATA RECORDS PER PHYSICAL DATA    C
C               RECORD.                                                C
C   IDSIZ    - THE NUMBER OF BITS PER PHYSICAL DATA RECORD.            C
C   IRATE()  - THE ARRAY OF SAMPLE RATE FOR EACH RESPECTIVE VARIABLE.  C
C   IPOS()   - THE ARRAY OF INDEX POSITIONS FOR EACH RESPECTIVE        C
C               VARIABLE IN A DATA RECORD ARRAY.                       C
C   TERM()   - THE ARRAY OF TERM VALUES FOR EACH RESPECTIVE VARIABLE.  C
C   FACTR()  - THE ARRAY OF FACTOR VALUES FOR EACH RESPECTIVE VARIABLE.C
C   NVAR     - THE NUMBER OF VARIABLES SAMPLED FOR THIS DATA FILE.     C
C   NLOGRC   - A COUNTER USED TO DETERMINE THE CURRENT LOGICAL DATA    C
C               RECORD BEING PROCESSED.                                C
C   INBUF()  - THE ARRAY USED TO CHECK FOR AN EIGHT-CHARACTER          C
C               IDENTIFIER AT THE BEGINNING OF A LOGICAL HEADER RECORD.C
C   VNAME()  - THE ARRAY TO STORE THE RESPECTIVE VARIABLE NAMES.       C
C   LOGBIT   - THE EIGHT-CHARACTER STRING ' LOGBIT '.                  C
C   DATLOG   - THE EIGHT-CHARACTER STRING ' DATLOG '.                  C
C   ORDVAR   - THE EIGHT-CHARACTER STRING ' ORDVAR '.                  C
C   LETVAR   - THE EIGHT-CHARACTER STRING ' LETVAR '.                  C
C   DATSIZ   - THE EIGHT-CHARACTER STRING ' DATSIZ '.                  C
C   DEBUF()  - THE ARRAY USED TO DECODE NUMERIC VALUES FROM AN         C
C               ASCII REPRESENTATION OF A LOGICAL HEADER RECORD.       C
C   NORDV    - A VARIABLE USED TO DETERMINE THE NUMBER OF TIMES THE    C
C               ' ORDVAR ' IDENTIFIER HAS BEEN ENCOUNTERED.            C
C   NRATE    - A VARIABLE USED AS AN INDEX INTO IRATE STORING THE      C
C               NUMBER OF IRATE VALUES READ.                           C
C   NTERM    - A VARIABLE USED AS AN INDEX INTO TERM AND FACTR STORING C
C               THE NUMBER OF TERM AND FACTR VALUES READ.              C
C   NREC     - A COUNTER USED TO KEEP TRACK OF THE NUMBER OF PHYSICAL  C
C               HEADER RECORDS READ.                                   C
C   INDX     - THE CURRENT INDEX INTO THE INBUF ARRAY.                 C
C   INDXD    - THE CURRENT INDEX INTO THE DEBUF ARRAY.                 C
C                                                                      C
C    THIS ROUTINE WAS WRITTEN BY MIKE DANIELS, SEPTEMBER 1984.         C
C    QUESTIONS AND/OR COMMENTS MAY BE GIVEN TO RON RUTH BY CALLING     C
C    (303)497-1084 (email address = ruth@ncar.ucar.edu).               C
C                                                                      C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      PARAMETER (NVARMX=300)
      COMMON / GENBLK / ILGBIT,IDATLG,IRATE(NVARMX),IPOS(NVARMX),
     &                  TERM(NVARMX),FACTR(NVARMX),NVAR,NLOGRC,IDSIZ
      CHARACTER*8 INBUF(100),VNAME(NVARMX),LOGBIT,DATLOG,ORDVAR,LETVAR,
     &            DATSIZ
      CHARACTER*80 DEBUF(10)
      EQUIVALENCE (DEBUF,INBUF)
C
C-----> INITIALIZE THE IDENTIFIERS
C
      LOGBIT=' LOGBIT '
      DATLOG=' DATLOG '
      ORDVAR=' ORDVAR '
      LETVAR=' LETVAR '
      DATSIZ=' DATSIZ '
C
C-----> INITIALIZE THE COUNTERS
C
      NORDV=0
      NRATE=0
      NTERM=0
      NREC=0
   10 NREC=NREC+1
      READ(LUIN,ERR=20,END=150) DEBUF
      GOTO 40
C
C-----> READ ERROR
C
   20 WRITE(LUOUT,30) NREC
   30 FORMAT(/,' >>> READ ERROR ON HEADER FILE RECORD ',
     &       'NUMBER ',I4,/)
      GOTO 10
C
C-----> GOOD READ
C
C
C-----> WRITE OUT EACH LOGICAL RECORD WHILE SEARCHING FOR THE
C-----> IDENTIFIERS
C
   40 DO 120 INDX=1,100,10
        INDXD=INDX/10+1
        WRITE(LUOUT,60) DEBUF(INDXD)
   60   FORMAT(1X,A80)
        IF (INBUF(INDX).EQ.LOGBIT) THEN
C
C-----> DECODE THE NUMBER OF BITS PER LOGICAL DATA RECORD
C
           READ(DEBUF(INDXD),80) ILGBIT
   80      FORMAT(10X,I8,62X)
         ELSE IF (INBUF(INDX).EQ.DATLOG) THEN
C
C-----> DECODE THE NUMBER OF LOGICAL DATA RECORDS PER PHYSICAL DATA
C-----> RECORD
C
           READ(DEBUF(INDXD),90) IDATLG
   90      FORMAT(10X,I4,66X)
         ELSE IF (INBUF(INDX).EQ.DATSIZ) THEN
C
C-----> DECODE THE NUMBER OF BITS PER PHYSICAL RECORD
C
           READ(DEBUF(INDXD),80) IDSIZ
         ELSE IF (INBUF(INDX).EQ.ORDVAR) THEN
           NORDV=NORDV+1
         ELSE IF (INBUF(INDX).EQ.LETVAR) THEN
           IF (NORDV.EQ.2) THEN
C
C-----> DECODE A VARIABLE'S SAMPLE RATE, FROM THE BIT LOCATION
C-----> COMPUTE THE INDEX INTO A LOGICAL DATA RECORD AND READ THE
C-----> VARIABLE NAME
C
              NRATE=NRATE+1
              READ(DEBUF(INDXD),100) IRATE(NRATE),IFBIT,VNAME(NRATE)
  100         FORMAT(28X,I6,5X,I8,15X,A8,10X)
              IPOS(NRATE)=((IFBIT-1)/32)+1
            ELSE IF (NORDV.EQ.3) THEN
C
C-----> DECODE A VARIABLE'S TERM AND FACTR
C
              NTERM=NTERM+1
              READ(DEBUF(INDXD),110) TERM(NTERM),FACTR(NTERM)
  110         FORMAT(16X,F15.8,1X,F14.8,34X)
              END IF
           END IF
  120 CONTINUE
      GOTO 10
C
C-----> EOF SENSED
C
  150 WRITE(LUOUT,160) NREC-1
  160 FORMAT(/,' >>> EOF SENSED ON HEADER FILE AFTER ',I4,' RECORDS',/)
C
C-----> ASSIGN THE NUMBER OF VARIABLES AND SET THE NLOGRC POINTER TO
C-----> IDATLG SO THAT WHEN GENDAT IS CALLED A PHYSICAL DATA RECORD IS
C-----> READ IMMEDIATELY
C
      NVAR=NRATE
      NLOGRC=IDATLG
C
C-----> WRITE OUT A VARIABLE TABLE
C
      WRITE(LUOUT,170)
  170 FORMAT(//,1X,'  NAME  ',5X,'INDEX',5X,'RATE',/)
      DO 180 I=1,NVAR
  180 WRITE(LUOUT,190) VNAME(I),IPOS(I),IRATE(I)
  190 FORMAT(1X,A8,5X,I5,5X,I4)
      RETURN
      END

      SUBROUTINE GENDAT (LUIN,LUOUT,DATARY,ISTAT)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C     SUBROUTINE GENDAT WILL READ A LOGICAL DATA RECORD.  IT FIRST     C
C CHECKS TO SEE IF IT IS NECESSARY TO READ A PHYSICAL RECORD.  IT THEN C
C CONVERTS EACH INTEGER DATA VALUE TO A REAL DATA VALUE THROUGH        C
C SUBROUTINE UNPCK.                                                    C
C                                                                      C
C ARGUMENTS USED BY GENDAT:                                            C
C   LUIN     - THE VARIABLE USED TO STORE THE LOGICAL UNIT NUMBER OF   C
C               THE INPUT DEVICE FROM WHICH THE DATA ARE READ.         C
C   LUOUT    - THE LOGICAL UNIT NUMBER OF THE DEVICE TO WHICH ALL      C
C               ERROR MESSAGES ARE TO BE WRITTEN.                      C
C   DATARY() - THE FLOATING-POINT ARRAY WHERE THE UNPACKED DATA ARE TO C
C               BE STORED.                                             C
C   ISTAT    - A STATUS RETURN VARIABLE.                               C
C                ISTAT=0   SUCCESSFUL READ                             C
C                ISTAT=1   EOF SENSED                                  C
C                ISTAT=-1  READ ERROR OCCURRED                         C
C                                                                      C
C VARIABLES IN GENDAT:                                                 C
C   NLOGRC   - A VARIABLE USED TO KEEP TRACK OF THE CURRENT LOGICAL    C
C               RECORD BEING PROCESSED.  IT IS USED TO DETERMINE       C
C               WHETHER OR NOT A NEW PHYSICAL RECORD NEEDS TO BE READ. C
C   INDX     - A POINTER USED TO POSITION A LOGICAL RECORD WITHIN A    C
C               PHYSICAL RECORD.                                       C
C                                                                      C
C            WRITTEN BY MIKE DANIELS, SEPTEMBER, 1984.                 C
C                                                                      C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      PARAMETER (NVARMX=300)
      COMMON / GENBLK / ILGBIT,IDATLG,IRATE(NVARMX),IPOS(NVARMX),
     &                  TERM(NVARMX),FACTR(NVARMX),NVAR,NLOGRC,IDSIZ
C
C-----> SET PARAMETER IWDSZ TO THE WORD SIZE OF YOUR MACHINE IN BITS
C
      PARAMETER (IWDSZ=32)
C
C-----> SET PARAMETER IRSIZ TO THE MAXIMUM EXPECTED NUMBER OF BITS
C-----> PER PHYSICAL DATA RECORD
C
      PARAMETER (IRSIZ=100000)
C
C-----> CALCULATE THE MAXIMUM EXPECTED WORDS PER PHYSICAL RECORD
C
      PARAMETER (ISIZ=IRSIZ/IWDSZ)
C
C-----> SET INDAT ARRAY TO ITS EXPECTED MAXIMUM DIMENSION
C

      DIMENSION INDAT(ISIZ),DATARY(1)
      SAVE INDAT
C
C-----> CALCULATE THE NUMBER OF WORDS PER PHYSICAL RECORD
C
      IWORDS=IDSIZ/IWDSZ
C
C-----> DETERMINE WHETHER OR NOT IT IS NECESSARY TO READ THE NEXT
C-----> PHYSICAL DATA RECORD
C
      IF (NLOGRC.GE.IDATLG) THEN
         NLOGRC=0
         READ(LUIN,ERR=20,END=100,IOSTAT=IOS) (INDAT(I),I=1,IWORDS)
         END IF
      ISTAT=0
      GOTO 50
C
C-----> READ ERROR
C
   20 ISTAT=-1
      WRITE(LUOUT,30) IOS
   30 FORMAT(/,' >>> READ ERROR ON DATA FILE, IOSTAT=',I10,/)
C
C-----> GOOD READ
C
   50 NLOGRC=NLOGRC+1
      INDX=(ILGBIT*(NLOGRC-1))/IWDSZ+1
      CALL UNPCK(DATARY,INDAT(INDX))
      RETURN
C
C-----> EOF SENSED
C
  100 ISTAT=1
      WRITE(LUOUT,110)
  110 FORMAT(/,' >>> EOF SENSED ON DATA FILE',/)
      RETURN
      END

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                      C
C  SAMPLE UNPCK TO BE USED WITH 16-BIT WORD MACHINES                   C
C                                                                      C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                      C
C                                                                      C
      SUBROUTINE UNPCK (DATARY,IDAT)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                      C
C     SUBROUTINE UNPCK CONVERTS THE 32-BIT INTEGER DATA STORED IN IDAT C
C TO A FLOATING-POINT REAL NUMBER TO BE PLACED IN DATARY USING THE     C
C GENPRO II METHOD OF SCALING.                                         C
C                                                                      C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      PARAMETER (NVARMX=300)
      COMMON / GENBLK / ILGBIT,IDATLG,IRATE(NVARMX),IPOS(NVARMX),
     &                  TERM(NVARMX),FACTR(NVARMX),NVAR,NLOGRC,IDSIZ
      INTEGER*4 IDAT(1),IDSIZ,ILGBIT
      DIMENSION DATARY(1)
      IC=0
      DO 11 I=1,NVAR
      DO 10 J=1,IRATE(I)
      IC=IC+1
  10  DATARY(IC)=(IDAT(IC)/FACTR(I))-TERM(I)
  11  CONTINUE
      RETURN
      END

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                      C
C SAMPLE UNPCK TO BE USED WITH 32-BIT WORD MACHINES                    C
C                                                                      C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                      C
C                                                                      C
      SUBROUTINE UNPCK (DATARY,IDAT)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                      C
C     SUBROUTINE UNPCK CONVERTS THE 32-BIT INTEGER DATA STORED IN IDAT C
C TO A FLOATING-POINT REAL NUMBER TO BE PLACED IN DATARY USING THE     C
C GENPRO II METHOD OF SCALING.                                         C
C                                                                      C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      PARAMETER (NVARMX=300)
      COMMON / GENBLK / ILGBIT,IDATLG,IRATE(NVARMX),IPOS(NVARMX),
     &                  TERM(NVARMX),FACTR(NVARMX),NVAR,NLOGRC,IDSIZ
      DIMENSION DATARY(1),IDAT(1)
      IC=0
      DO 11 I=1,NVAR
      DO 10 J=1,IRATE(I)
      IC=IC+1
  10  DATARY(IC)=(IDAT(IC)/FACTR(I))-TERM(I)
  11  CONTINUE
      RETURN
      END

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                      C
C SAMPLE UNPCK TO BE USED WITH 32-BIT DEC MACHINES                     C
C                                                                      C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                      C
C                                                                      C
      SUBROUTINE UNPCK (DATARY,IDAT)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                      C
C     THIS SUBROUTINE IS WRITTEN FOR A DEC MACHINE ONLY !!!!!  IT DOES C
C A BYTE SWAP THAT IS NOT NECESSARY FOR OTHER MACHINES.                C
C                                                                      C
C                                                                      C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      PARAMETER (NVARMX=300)
      COMMON / GENBLK / ILGBIT,IDATLG,IRATE(NVARMX),IPOS(NVARMX),
     &                  TERM(NVARMX),FACTR(NVARMX),NVAR,NLOGRC,IDSIZ
      DIMENSION DATARY(1)
      BYTE IDAT(1)
      IMASK=255
      IC=0
      DO 11 I=1,NVAR
      DO 10 J=1,IRATE(I)
      IC=IC+1
C
C-----> BECAUSE OF A DEC QUIRK, WE MUST SWAP THE BYTES WITHIN A 4-BYTE
C-----> WORD.
C
C      IB1=(IMASK.AND.IDAT(IC*4-3))*16777216
C  Alternative for above calculation suggested by Rob Kieslar of DRI to
C   prevent an integer overflow when IDAT(IC*4-3) evaluates to -2.
      IB1=ISHFT(ZEXT(IDAT(IC*4-3)),24)
      IB2=(IMASK.AND.IDAT(IC*4-2))*65536
      IB3=(IMASK.AND.IDAT(IC*4-1))*256
      IB4=(IMASK.AND.IDAT(IC*4))
      I32=IB1+IB2+IB3+IB4
  10  DATARY(IC)=(I32/FACTR(I))-TERM(I)
  11  CONTINUE
      RETURN
      END

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                      C
C SAMPLE UNPCK TO BE USED WITH 64-BIT MACHINES                         C
C                                                                      C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                      C
C                                                                      C
      SUBROUTINE UNPCK (DATARY,IDAT)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                      C
C     SUBROUTINE UNPCK CONVERTS THE 32-BIT INTEGER DATA STORED IN IDAT C
C TO A FLOATING-POINT REAL NUMBER TO BE PLACED IN DATARY USING THE     C
C GENPRO II METHOD OF SCALING.                                         C
C                                                                      C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      PARAMETER (NVARMX=300)
      COMMON / GENBLK / ILGBIT,IDATLG,IRATE(NVARMX),IPOS(NVARMX),
     &                  TERM(NVARMX),FACTR(NVARMX),NVAR,NLOGRC,IDSIZ
      DIMENSION DATARY(1),IDAT(1)
      INTEGER HIBITS,LOBITS
C
C-----> HIGH IS A LOGICAL VARIABLE USED TO DENOTE WHEN WE ARE LOOKING
C-----> AT THE HIGH 32 BITS OF A WORD (HIGH WILL BE .TRUE.) AND WHEN
C-----> WE ARE LOOKING AT THE LOWER 32 BITS OF A WORD (HIGH WILL BE
C-----> .FALSE.)
C
      LOGICAL HIGH
C
C-----> MASK TO GRAB THE 32 MOST SIGNIFICANT BITS
C
      DATA HIBITS/1777777777740000000000B/
C
C-----> MASK TO GRAB THE 32 LEAST SIGNIFICANT BITS
C
      DATA LOBITS/37777777777B/
C
C-----> II IS THE INDEX INTO IDAT, IR IS THE INDEX INTO DATARY
C
      II=1
      IR=0
C
C-----> CHECK TO SEE IF WE MUST START IN THE MIDDLE OF A WORD
C
      IF (MOD(ILGBIT,64).NE.0.AND.MOD(NLOGRC,2).EQ.0) THEN
         HIGH=.FALSE.
       ELSE
         HIGH=.TRUE.
         END IF
      DO 11 I=1,NVAR
      DO 10 J=0,(IRATE(I)-1)
      IF (HIGH) THEN
C
C-----> VALUE IS IN UPPER HALF OF WORD, SHIFT IT RIGHT 32 BITS
C
         ITST=(IDAT(II).AND.HIBITS)/2**32
         HIGH=.FALSE.
       ELSE
C
C-----> VALUE IS IN LOWER HALF OF WORD, MASK OFF 32 LSB'S, UPDATE
C-----> IDAT INDEX SO THAT THE NEXT WORD WILL BE DONE
C
         ITST=(IDAT(II).AND.LOBITS)
         HIGH=.TRUE.
         II=II+1
         ENDIF
      IR=IR+1
C
C-----> UNSCALE THE DATA AND STORE IN DATARY
C
  10  DATARY(IR)=(ITST/FACTR(I))-TERM(I)
  11  CONTINUE
      RETURN
      END
